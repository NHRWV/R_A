---
title: "HW4_201521466_김남현"
author: "HW4_201521466_김남현"
date: '2019 10 5 '
output: html_document
---
### 갤럭시 노트10과 아이폰11의 최근 일주일 간 트윗을 수집 및 일별 빈도 비교
```{r}
library(syuzhet)
library(twitteR)
library(lubridate)
library(dplyr)
library(tm)
library(stringr)
library(RColorBrewer)
library(igraph)
library(data.table)
library(ggplot2)
library(tinytex)
setwd("C:/Users/Namlister/Desktop/Assignments/R_A")

CONSUMER_SECRET <- "E8u5PZvaNvCNXIi34yEE8Efs8AEz2TxJbvyjpjWi2OpE3HENDQ"
CONSUMER_KEY <- "hvHT3aR6Reugq4OMSEUG0sums"
ACCESS_SECRET <- "BbKb4BFRfzyVppA380bh5FHxEjgV2s0PefdNy7Avthmsy"
ACCESS_TOKEN <- "701807611465740288-g0Dp8IPrCv8VTEJfKRStR1dGHONeoxN"


setup_twitter_oauth(consumer_key = CONSUMER_KEY,
                    consumer_secret = CONSUMER_SECRET,
                    access_token = ACCESS_TOKEN,
                    access_secret = ACCESS_SECRET)

searchTerm1 <- "#GalaxyNote10"
searchTerm2 <- "#iPhone11"

# 갤럭시와 아이폰의 최근 일주일 데이터 수집.
tweetsG = searchTwitter(searchTerm1, since = "2019-09-28", n=11000,lang = "en") #갤럭시.
tweetsI = searchTwitter(searchTerm2, since = "2019-09-28", n=12000,lang = "en") #아이폰.

tweetsG.df = twListToDF(tweetsG) #데이터프레임화.
tweetsI.df = twListToDF(tweetsI)

#View(tweetsI.df)

#생성된 날짜에서 연월일만 추출해서 새로운 칼럼 생성한 후 따로 데이터프레임화.
G_ymd <- transmute(tweetsG.df, G_ymd = date(tweetsG.df$created))

I_ymd <- transmute(tweetsI.df, I_ymd = date(tweetsI.df$created))

# 갤럭시와 아이폰 빈도 비교.
table(G_ymd$G_ymd)
table(I_ymd$I_ymd)
```
갤럭시보다 아이폰에 대한 언급이 훨씬 많다는 것을 알 수 있다. 갤럭시의 경우, 30일날 언급되는 경우가 갑자기 늘어났다가 그 이후로 점차 언급이 점점 줄어드는 것을 관찰할 수 있다.

### 수집된 트윗의 감정분포를 비교
```{r}
# 갤럭시와 아이폰에 관한 트윗에서 감정적인 텍스트를 추출한다.
G_Sentiments <- get_nrc_sentiment(tweetsG.df$text)
I_Sentiments <- get_nrc_sentiment(tweetsI.df$text)


tweetsG <- cbind(tweetsG.df, G_Sentiments)
tweetsI <- cbind(tweetsI.df, I_Sentiments)

# 데이터프레임에서 감정에 관한 칼럼들만 따로 추출한다.
sentimentTotalsG <- data.frame(colSums(tweetsG[,c(17:26)]))
sentimentTotalsI <- data.frame(colSums(tweetsI[,c(17:26)]))

# 감정의 종류별로 등장하는 총 횟수를 정리한다.
names(sentimentTotalsG) <- "count"
names(sentimentTotalsI) <- "count"
sentimentTotalsG <- cbind("sentiment" = rownames(sentimentTotalsG), sentimentTotalsG)
sentimentTotalsI <- cbind("sentiment" = rownames(sentimentTotalsI), sentimentTotalsI)
rownames(sentimentTotalsG) <- NULL
rownames(sentimentTotalsI) <- NULL


# 시각화
ggplot(data = sentimentTotalsG, aes(x = sentiment, y = count)) +
  geom_bar(aes(fill = sentiment), stat = "identity") +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45)) +
  xlab("Sentiment") + ylab("Total Count") + ggtitle("GalaxyNote10")

ggplot(data = sentimentTotalsI, aes(x = sentiment, y = count)) +
  geom_bar(aes(fill = sentiment), stat = "identity") +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45)) +
  xlab("Sentiment") + ylab("Total Count") + ggtitle("iPhone11")
```
감정 종류에 따른 분포는 대략적으로 비슷해보인다. 다만 갤럭시의 경우 아이폰보다 negative 의견이 많으나 positive 의견이 압도적으로 많은 것을 볼 수 있다. 

### 각각의 주제에서 가장 많은 트윗을 올린 계정 2개를 대상으로 Follower network(1차만)을 구성하여 시각화
```{r}
# 갤럭시와 아이폰에 관한 트윗을 가장 많이 올린 계정을 각각 찾는다.
head(sort(table(tweetsG.df$screenName), decreasing = T))
head(sort(table(tweetsI.df$screenName), decreasing = T))

# 특정 계정의 팔로워들을 추출하는 함수
get_follower_list <- function(userName){
  
  twitterUser <- getUser(userName)
  twitterUserFollowerIDs<-twitterUser$getFollowers(retryOnRateLimit=1)
  
  
  return (sapply(twitterUserFollowerIDs,screenName))
}

append_to_df<-function(dt, elems)
{ 
  return(rbindlist(list(dt,  elems),use.names = TRUE))
}


# 갤럭시와 아이폰에 관한 트윗을 가장 많이 올린 계정이다.
coreUserName_G <- "whitestonedome"
coreUserName_I <- "sshanthan8"


whitestonedome <- getUser(coreUserName_G)
sshanthan8 <- getUser(coreUserName_I)
# 팔로워 리스트를 추출한다.
whitestonedome_follower_IDs <- whitestonedome$getFollowers(retryOnRateLimit=10, n = 100)
sshanthan8_follower_IDs <- sshanthan8$getFollowers(retryOnRateLimit=10, n = 100)

whitestonedome_followers_df = rbindlist(lapply(
  whitestonedome_follower_IDs,as.data.frame
))
sshanthan8_followers_df = rbindlist(lapply(
  sshanthan8_follower_IDs,as.data.frame
))

# 팔로워 목록 중에서 규모가 어느 정도 있는 계정만 걸러낸다.
G_filtered <- subset(whitestonedome_followers_df, 
                      followersCount < 100 &
                        followersCount > 50 &
                        #statusesCount > 10000 & #to reduce number of followers
                        # statusesCount > 100 & 
                        # statusesCount < 5000 & #too many tweets from bots?
                        protected==FALSE)
G_filtered_follower <- G_filtered$screenName

I_filtered <- subset(sshanthan8_followers_df, 
                     followersCount < 100 &
                       followersCount > 50 &
                       #statusesCount > 10000 & #to reduce number of followers
                       # statusesCount > 100 & 
                       # statusesCount < 5000 & #too many tweets from bots?
                       protected==FALSE)
I_filtered_follower <- I_filtered$screenName

# 데이터프레임으로 만들어서 정리한다.
edge_df_G <- data.frame(from=G_filtered_follower,
                    to=rep(coreUserName_G, 
                           length(G_filtered_follower)), 
                    stringsAsFactors=FALSE)
edge_df_I <- data.frame(from=I_filtered_follower,
                        to=rep(coreUserName_I, 
                               length(I_filtered_follower)), 
                        stringsAsFactors=FALSE)


counter = 1
for(follower in G_filtered_follower){
  
  followerScreenNameList_G <- get_follower_list(follower)
  Sys.sleep(30)
  print(paste("Processing completed for:",
              follower,
              "(",counter,"/",
              length(G_filtered_follower),")"
  ))
  
  edge_df_G <- append_to_df(edge_df_G,list(from=followerScreenNameList_G,
                                       to=rep(follower, 
                                              length(followerScreenNameList_G))))
  counter <- counter + 1
}
save(edge_df_G, file = "edge_df_G.Rda")
load("edge_df_G.Rda")

counter_I = 1
for(follower in I_filtered_follower){
  
  followerScreenNameList_I <- get_follower_list(follower)
  Sys.sleep(30)
  print(paste("Processing completed for:",
              follower,
              "(",counter_I,"/",
              length(I_filtered_follower),")"
  ))
  
  edge_df_I <- append_to_df(edge_df_I,list(from=followerScreenNameList_I,
                                           to=rep(follower, 
                                                  length(followerScreenNameList_I))))
  counter_I <- counter_I + 1
}
save(edge_df_I, file = "edge_df_I.Rda")
load("edge_df_I.Rda")

# 시각화 준비
net_G <- graph_from_data_frame(edge_df_G, directed=T)
net_I <- graph_from_data_frame(edge_df_I, directed=T)

table(edge_df_G$to)
table(edge_df_I$to)

edge_df_G[to=="whitestonedome"]$from
edge_df_G[from=="whitestonedome"]$to

edge_df_I[to=="sshanthan8"]$from
edge_df_I[from=="sshanthan8"]$to
# 네트워크 시각화
net_G <- simplify(net_G, remove.multiple = F, remove.loops = T)
net_I <- simplify(net_I, remove.multiple = F, remove.loops = T)


# 각각의 차트의 사이즈와 글자 크기를 조정한다.
deg_G <- degree(net_G, mode="all")
V(net_G)$size <- deg_G*0.05 + 1
V(net_G)[name == coreUserName_G]$size <- 15
V(net_G)[size >= 15]$name
V(net_G)[name == coreUserName_G]$size

deg_I <- degree(net_I, mode="all")
V(net_I)$size <- deg_I*0.05 + 1
V(net_I)[name == coreUserName_I]$size <- 15
V(net_I)[size >= 15]$name
V(net_I)[name == coreUserName_I]$size

# 차트에 사용할 색을 지정한다.
pal3 <- brewer.pal(10, "Set3")


plot(net_G, edge.arrow.size=0.1,
     
     vertex.label = ifelse(V(net_G)$size >= 5, V(net_G)$name, NA),
     vertex.color = pal3)
plot(net_I, edge.arrow.size=0.1,
     
     vertex.label = ifelse(V(net_I)$size >= 5, V(net_I)$name, NA),
     vertex.color = pal3)
```
